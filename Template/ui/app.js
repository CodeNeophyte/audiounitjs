// Generated by CoffeeScript 1.3.3
(function() {
  var bgColor, gridColor, numScopeData, traceColor, triggerColor;

  bgColor = '0,0,0';

  traceColor = '10,237,87';

  triggerColor = '238,55,103';

  gridColor = '237,108,33';

  numScopeData = 400;

  $(function() {
    var canvasSize, ctx, doDrawScope, drawScope, gridAlpha, scopeCanvas, shouldDrawScope, syncDial;
    canvasSize = ($('#scopeData')).width();
    scopeCanvas = ($('#scopeData'))[0];
    ctx = scopeCanvas.getContext('2d');
    ctx.beginPath();
    ctx.arc(canvasSize / 2, canvasSize / 2, canvasSize / 2, 0, Math.PI * 2, true);
    ctx.clip();
    shouldDrawScope = true;
    gridAlpha = .1;
    drawScope = function() {
      var data, valToX, valToY;
      if (!shouldDrawScope) {
        return;
      }
      shouldDrawScope = false;
      valToX = function(val) {
        return canvasSize / 10 + (val / numScopeData) * canvasSize * .8;
      };
      valToY = function(val) {
        return ~~(canvasSize / 2 - canvasSize / 2 * val);
      };
      data = AudioUnit.ScopeData.Get();
      (function() {
        ctx.fillStyle = "rgba(" + bgColor + ",1)";
        return ctx.fillRect(0, 0, canvasSize, canvasSize);
      })();
      (function() {
        var trigY;
        ctx.beginPath();
        ctx.strokeStyle = "rgb(" + triggerColor + ")";
        trigY = valToY(AudioUnit.Trigger.Get());
        ctx.moveTo(0, trigY);
        ctx.lineTo(canvasSize / 10, trigY);
        ctx.moveTo(canvasSize / 20, trigY);
        ctx.lineTo(canvasSize / 20 - canvasSize / 100, trigY + 5);
        ctx.moveTo(canvasSize / 20, trigY);
        ctx.lineTo(canvasSize / 20 - canvasSize / 100, trigY - 5);
        return ctx.stroke();
      })();
      (function() {
        var addHatchH, addHatchV, addLineH, addLineV, divsPerQuadX, divsPerQuadY, gridHeight, gridOrigX, gridOrigY, gridSpaceX, gridSpaceY, gridWidth, hatch, i, tAlpha, _i, _j;
        ctx.beginPath();
        if (gridAlpha > .05) {
          tAlpha = gridAlpha * .95 + Math.random() / 10;
        } else {
          tAlpha = gridAlpha;
        }
        ctx.strokeStyle = "rgba(" + gridColor + ", " + tAlpha + ")";
        ctx.lineWidth = 2;
        gridWidth = canvasSize * .8;
        gridHeight = canvasSize / 2;
        gridOrigX = (canvasSize - gridWidth) / 2;
        gridOrigY = (canvasSize - gridHeight) / 2;
        ctx.strokeRect(gridOrigX, gridOrigY, gridWidth, gridHeight);
        addLineH = function(y) {
          ctx.moveTo(gridOrigX, y);
          return ctx.lineTo(gridOrigX + gridWidth, y);
        };
        addLineV = function(x) {
          ctx.moveTo(x, gridOrigY);
          return ctx.lineTo(x, gridOrigY + gridHeight);
        };
        ctx.beginPath();
        addLineH(canvasSize / 2);
        addLineV(canvasSize / 2);
        ctx.stroke();
        ctx.lineWidth = 1;
        divsPerQuadX = 4;
        divsPerQuadY = 3;
        gridSpaceX = gridWidth / 2 / (divsPerQuadX + 1);
        gridSpaceY = gridHeight / 2 / (divsPerQuadY + 1);
        hatch = canvasSize / 100;
        addHatchH = function(y) {
          ctx.moveTo(canvasSize / 2 - hatch, y);
          return ctx.lineTo(canvasSize / 2 + hatch, y);
        };
        addHatchV = function(x) {
          ctx.moveTo(x, canvasSize / 2 - hatch);
          return ctx.lineTo(x, canvasSize / 2 + hatch);
        };
        ctx.beginPath();
        for (i = _i = 1; 1 <= divsPerQuadY ? _i <= divsPerQuadY : _i >= divsPerQuadY; i = 1 <= divsPerQuadY ? ++_i : --_i) {
          addLineH(canvasSize / 2 - (gridSpaceY * i));
          addLineH(canvasSize / 2 + (gridSpaceY * i));
          addHatchH(canvasSize / 2 + (gridSpaceY * i) + gridSpaceY / 2);
          addHatchH(canvasSize / 2 - (gridSpaceY * i) - gridSpaceY / 2);
        }
        for (i = _j = 1; 1 <= divsPerQuadX ? _j <= divsPerQuadX : _j >= divsPerQuadX; i = 1 <= divsPerQuadX ? ++_j : --_j) {
          addLineV(canvasSize / 2 - (gridSpaceX * i));
          addLineV(canvasSize / 2 + (gridSpaceX * i));
          addHatchV(canvasSize / 2 + (gridSpaceX * i) + gridSpaceX / 2);
          addHatchV(canvasSize / 2 - (gridSpaceX * i) - gridSpaceX / 2);
        }
        return ctx.stroke();
      })();
      return (function() {
        var alpha, i, j, k, tAlpha, _i, _j, _results;
        ctx.beginPath();
        ctx.moveTo(valToX(0), valToY(data[0]));
        for (i = _i = 1; 1 <= numScopeData ? _i < numScopeData : _i > numScopeData; i = 1 <= numScopeData ? ++_i : --_i) {
          ctx.lineTo(valToX(i), valToY(data[i]));
        }
        k = 3;
        ctx.strokeStyle = 'green';
        _results = [];
        for (j = _j = k; k <= 1 ? _j <= 1 : _j >= 1; j = k <= 1 ? ++_j : --_j) {
          ctx.lineWidth = j;
          alpha = Math.pow((k + 1 - j) / k, 2);
          tAlpha = alpha * .9 + Math.random() / 5;
          ctx.strokeStyle = "rgba(" + traceColor + "," + tAlpha + ")";
          _results.push(ctx.stroke());
        }
        return _results;
      })();
    };
    doDrawScope = function() {
      shouldDrawScope = true;
      return setTimeout(drawScope, 0);
    };
    drawScope();
    AudioUnit.ScopeData.OnPropertyChange = doDrawScope;
    syncDial = function() {
      return ($('#trigger')).val(~~(AudioUnit.Trigger.Get() * 100)).trigger('change');
    };
    AudioUnit.Trigger.OnParameterChange = function(v) {
      doDrawScope();
      return syncDial();
    };
    ($('#trigger')).dial({
      start: function() {
        return AudioUnit.Trigger.BeginGesture();
      },
      stop: function() {
        return AudioUnit.Trigger.EndGesture();
      },
      change: function(v) {
        AudioUnit.Trigger.Set(v / 100);
        return doDrawScope();
      },
      flatMouse: true,
      fgColor: "rgb(" + triggerColor + ")",
      bgColor: "rgb(" + bgColor + ")"
    });
    ($('#grid')).dial({
      change: function(v) {
        gridAlpha = v / 100;
        return doDrawScope();
      },
      flatMouse: true,
      fgColor: "rgb(" + gridColor + ")",
      bgColor: "rgb(" + bgColor + ")"
    });
    return syncDial();
  });

}).call(this);
